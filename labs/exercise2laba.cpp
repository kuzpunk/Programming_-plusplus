//Задание 2a. Неявное приведение типов данных.
	//Объясните разницу результата при выполнении (1) и (2):
	//Покажите явно (напишите в коде) преобразования, которые неявно выполняет компилятор

	iInt=1;
	double dDouble1=iInt/3;		// (1) Здесь оба операнда — целые числа, поэтому выполняется целочисленное деление. Результат — 0, который затем неявно преобразуется в double.
	double dDouble2=iInt/3.;	// (2) Здесь одно из операндов — число с плавающей точкой, поэтому выполняется деление с плавающей точкой. Результат — 0.333333.


	// Ассоциативность операторов.
	// Синтаксис языка C допускает "цепочечное" присваивание
	// (как в строках (1) и (2)). Посмотрев результаты выполнения строк (1) и (2)
	// (значения переменных dDouble, fFloat, nInt, sShort, cByte), определите порядок 
	// выполения присваиваний при цепочечной записи и объясните результат.
	// Расставте скобки, явно определяющие порядок выполнения, как это сделал бы компилятор.
	// Объясните (в комментариях) предупреждения (warnings) компилятора.

	short sShort;
	dDouble=fFloat=iInt=sShort=cByte=3.3/3;	//Сначала выполняется деление 3.3 / 3, результатом которого будет 1.1. Затем это значение неявно приводится к типу int при присваивании в iInt, что даёт 1. Далее это значение передается по цепочке другим переменным.		// (1)
	
	cByte=sShort=iInt=fFloat=dDouble=3.3/3;	
    //Здесь результат деления сначала присваивается переменной dDouble, а затем передается по цепочке остальным переменным с соответствующим приведением.		// (2)

	//ниже Вам дан пример "небрежного" использования неявного приведения типов, что может 
	// привести к нежелательным результатам - объясните (в комментариях), к каким?
	// Напишите явно преобразования, которые неявно выполняет компилятор

	iInt	=	257; //
	cByte	=	iInt; //десь происходит потеря данных, так как значение 257 не помещается в диапазон типа char (-128 до 127), и остаются только младшие 8 бит. Результат — 1.

	unsigned char cN1=255, cN2=2, cSum;
	cSum = cN1 + cN2; //Здесь происходит выход за пределы диапазона типа unsigned char.
    //результат значение 1.
	//Сравните предыдущую строчку с приведенной ниже. Объясните (в комментариях),
	//почему в следующей строке не происходит выход за разрядную сетку
	// Напишите явно преобразования, которые неявно выполняет компилятор
	int iSum = cN1+cN2; //Здесь результат сложения (257) помещается в переменную типа int, и никаких переполнений не происходит.

	//Напишите, почему при сложении одинаковых значений (одинаковых в двоичной системе) 
	// в строках (1) и (2) получаются разные результаты
	// Напишите явно преобразования, которые неявно выполняет компилятор и объясните,
	// что при этом происходит
	char c1=0xff, c2=2; //c1 интерпретируется как -1 (в дополнительном коде), поэтому результат будет 1.
	unsigned char uc1=0xff, uc2=2;
	int iSum1= c1 + c2;   //(1)
	int iSum2= uc1 + uc2; //(2) uc1 интерпретируется как 255, поэтому результат сложения — 257.

	stop

	
// ***********************************************************
	//Задание 2b. Явное приведение типов данных.
	//Проинтерпретируйте результат (значения переменной dDouble) в строке (3)
	// Напишите явно преобразования, которые неявно выполняет компилятор
	int nTmp=100, nn=3;
	dDouble=3.3 + nTmp / nn; // (3)Здесь сначала выполняется целочисленное деление nTmp / nn, результатом которого будет 33. Затем это значение прибавляется к 3.3, и результатом будет 36.3.

	//Получите результат без потери точности с помощью оператора явного
	//приведения типа
//	double dDouble3=...		// (4)


	stop
